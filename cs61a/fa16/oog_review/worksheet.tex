\documentclass[twoside]{article}
\usepackage{cs61a}

\pagestyle{myheadings}

\lstset{
    language=Python,
    basicstyle=\ttfamily,
    showstringspaces=false
    keywordstyle=\color{black},
    commentstyle=\color{black},
    stringstyle=\color{black},
}

\def\semester{Fall 2016}
\title{\sc Orders of Growth Review}

\begin{document}
\thispagestyle{empty}
\maketitle

For Exercises 1-6 (below), identify the order of growth of the runtime as a function of $n$. As an example, your answer might be $O(\sqrt{n})$... or even $O(n^5\log{n})$. Note that this code will also be on the slides, along with the solutions to all of these problems!

\begin{enumerate}

%%%%%%%%%%%%%%%%%%%%%
\q{2}{Exercise 1}
%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}
def mystery1(n):
    n, result = str(n), ''
    num_digits = len(n)
    for i in range(num_digits):
        result += n[num_digits - i - 1]
    return result
\end{lstlisting}
~\\
\lstinline{_______________}

\begin{lstlisting}
def mystery2(n):
    n, result = 5, 0
    while n <= 3000:
        result += mystery1(n // 2)
        n += 1
    return result
\end{lstlisting}
~\\
\lstinline{_______________}

%%%%%%%%%%%%%%%%%%%%%
\q{3}{Exercise 2}
%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}
def mystery3(n):
    if n < 0 or n <= sqrt(n):
        return n
    return n + mystery3(n // 3)
\end{lstlisting}
~\\
\lstinline{_______________}

\begin{lstlisting}
def mystery4(n):
    if sqrt(n) <= 50:
        return 1
    return n * mystery4(n // 2)
\end{lstlisting}
~\\
\lstinline{_______________}

\begin{lstlisting}
def mystery5(n):
    for _ in range(int(sqrt(n))):
        n = 1 + 1
    return n
\end{lstlisting}
~\\
\lstinline{_______________}

%%%%%%%%%%%%%%%%%%%%%
\q{2}{Exercise 3}
%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}
def mystery6(n):
    while n > 1:
        x = n
        while x > 1:
            print(n, x)
            x = x // 2
        n -= 1
\end{lstlisting}
~\\
\lstinline{_______________}

\begin{lstlisting}
def mystery7(n):
    result = 0
    for i in range(n // 10):
        result += 1
        for j in range(10):
            result += 1
            for k in range(10 // n):
                result += 1
    return result
\end{lstlisting}
~\\
\lstinline{_______________}

%%%%%%%%%%%%%%%%%%%%%
\q{2}{Exercise 4}
%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}
def mystery8(n):
    if n == 0:
        return ''
    result, stringified = '', str(n)
    for digit in stringified:
        for _ in range(n):
            result += digit
    result += mystery8(n - 1)
    return result
\end{lstlisting}
~\\
\lstinline{_______________}

\begin{lstlisting}
def mystery9(n):
    total = 0
    for i in range(1, n):
        total *= 2
        if i % n == 0:
            total *= mystery9(n - 1)
            total *= mystery9(n - 2)
        elif i == n // 2:
            for j in range(1, n):
                total *= j
    return total
\end{lstlisting}
~\\
\lstinline{_______________}

\newpage

%%%%%%%%%%%%%%%%%%%%%
\q{2}{Exercise 5}
%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}
def mystery10(n):
    if n > 0:
        r1 = mystery10(-n)
        r2 = mystery10(n - 1)
        return r1 + r2
    return 1
\end{lstlisting}
~\\
\lstinline{_______________}

\begin{lstlisting}
def mystery11(n):
    if n < 1:
        return n
    def mystery12(n):
        i = 1
        while i < n:
            i *= 2
        return i
    return mystery11(n / 2) + mystery11(n / 2) + mystery12(n - 2)
\end{lstlisting}
~\\
\lstinline{_______________}

%%%%%%%%%%%%%%%%%%%%%
\q{2}{Exercise 6}
%%%%%%%%%%%%%%%%%%%%%

The orders of growth should now be functions of $m$ \emph{and} $n$.

\begin{lstlisting}
def mystery13(m, n):
    if n <= 1:
        return 0
    result = 0
    for i in range(3 ** m):
        result += i // n
    return result + mystery13(m - 5, n // 3)
\end{lstlisting}
~\\
\lstinline{_______________}

\begin{lstlisting}
def mystery14(m, n):
    result = 0
    for i in range(1, m):
        j = i * i
        while j <= n:
            result += j
            j += 1
        return result
\end{lstlisting}
~\\
\lstinline{_______________}

\newpage

%%%%%%%%%%%%%%%%%%%%%
\q{1}{Exercise 7}
%%%%%%%%%%%%%%%%%%%%%

Define $n$ to be the length of the input list. How much memory does the following program use as a function of $n$?

\begin{lstlisting}
def weighted_random_choice(lst):
    temp = []
    for i in range(len(lst)):
        temp.extend([lst[i]] * (i + 1))
    return random.choice(temp)
\end{lstlisting}
~\\
\lstinline{_______________}

%%%%%%%%%%%%%%%%%%%%%
\q{7}{Exercise 8}
%%%%%%%%%%%%%%%%%%%%%

Provide an algorithm that, given a sorted list $A$ of distinct integers, determines whether there is an index $i$ for which $A[i] = i$. Your algorithm should run in time $O(\log{n})$, where $n$ is the length of the list.

\begin{lstlisting}
def index_exists(A):
    def helper(lower, upper):
    
        if _________________________________:
        
            return _________________________
            
        mid_idx = (lower + upper) // 2
        
        if _________________________________:
            return True
            
        elif _______________________________:
        
            return _________________________
        else:
        
            return _________________________
            
    return _________________________________
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%
\q{3}{Summer 2013 MT2  $|$  Q2}
%%%%%%%%%%%%%%%%%%%%%

\begin{enumerate}
\subq{1}
What is the order of growth for a call to \texttt{fizzle}($n$)?

\begin{lstlisting}
def fizzle(n):
    if n <= 0:
        return n
    elif n % 23 == 0:
        return n
    return fizzle(n - 1)
\end{lstlisting}
~\\
\lstinline{_______________}

\newpage

\subq{1}
What is the order of growth for a call to \texttt{explode}($n$)?

\begin{lstlisting}
def boom(n):
    if n == 0:
        return 'BOOM!'
    return boom(n - 1)

def explode(n):
    if n == 0:
        return boom(n)
    i = 0
    while i < n:
        boom(n)
        i += 1
    return boom(n)
\end{lstlisting}
~\\
\lstinline{_______________}

\subq{1}
What is the order of growth for a call to \texttt{dreams}($n$)?

\begin{lstlisting}
def dreams(n):
    if n <= 0:
        return n
    if n > 0:
        return n + dreams(n // 2)
\end{lstlisting}
~\\
\lstinline{_______________}
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%
\q{4}{Summer 2014 MT2  $|$  Q6}
%%%%%%%%%%%%%%%%%%%%%

Consider the following function (assume that parameter $S$ is a list):

\begin{lstlisting}
def umatches(S):
    result = set()
    for item in S:
        if item in result:
            result.remove(item)
        else:
            result.add(item)
    return result
\end{lstlisting}

\begin{enumerate}
\subq{1}
Fill in the blank: The function \texttt{umatches} returns the set of all\\\\
\lstinline{_________________________________________________________________________}.

\subq{1}
Let's assume that the operations of adding to, removing from, or checking containment in a set each take roughly constant time. Give an asymptotic bound (the tightest you can) on the worst-case time for \texttt{umatches} as a function of $N = \texttt{len}(S)$.
~\\\\
\lstinline{_______________}

\subq{1}
Suppose that instead of having \texttt{result} be a set, we make it a list (so that it is initialized to \texttt{[]} and we use \texttt{.append} to add an item). What now is the worst-case time bound? You can assume that \texttt{.append} is a constant-time operation, and \texttt{.remove} and the \texttt{in} operator require time that is $\Theta(L)$ in the worst case, where $L$ is the length of the list operated on. Since we never add an item that is already in the list, each value appears at most once, just as for a Python set.
~\\\\
\lstinline{_______________}

\subq{1}
Now suppose that we consider only cases where the number of different values in list $S$ is at most 100, and we again use a list for \texttt{result}. What is the worst-case time now?
~\\\\
\lstinline{_______________}
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%
\q{2}{Summer 2015 MT2  $|$  Q5(d)}
%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}
def append(link, value):
    """Mutates LINK by adding VALUE to the end of LINK."""
    if link.rest is Link.empty:
        link.rest = Link(value)
    else:
        append(link.rest, value)

def extend(link1, link2):
    """Mutates LINK_1 so that all elements of LINK_2
    are added to the end of LINK_1.
    """
    while link2 is not Link.empty:
        append(link1, link2.first)
        link2 = link2.rest
\end{lstlisting}

\begin{enumerate}
\subq{1}
What order of growth describes the runtime of calling \texttt{append}? Give your function in terms of $n$, where $n$ is the number of elements in the input LINK.
~\\\\
\lstinline{_______________}

\subq{1}
Assuming the two input linked lists both contain $n$ elements, what order of growth best describes the runtime of calling \texttt{extend}?
~\\\\
\lstinline{_______________}
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%
\q{2}{Summer 2012 Final  $|$  Q2}
%%%%%%%%%%%%%%%%%%%%%

\begin{enumerate}
\subq{1}
What is the order of growth in $n$ of the runtime of \texttt{collide}, where $n$ is its input?

\begin{lstlisting}
def collide(n):
    lst = []
    for i in range(n):
        lst.append(i)
    if n <= 1:
        return 1
    if n <= 50:
        return collide(n - 1) + collide(n - 2)
    elif n > 50:
        return collide(50) + collide(49)
\end{lstlisting}
~\\
\lstinline{_______________}

\subq{1}
What is the order of growth in $n$ of the runtime of \texttt{into\_me}, where $n$ is its input?

\begin{lstlisting}
def crash(n):
    if n < 1:
        return n
    return crash(n - 1) * n
\end{lstlisting}

\newpage

\begin{lstlisting}
def into_me(n):
    lst = []
    for i in range(n):
        lst.append(i)
    sum = 0
    for elem in lst:
        sum = sum + crash(n) + crash(n)
    return sum
\end{lstlisting}
~\\
\lstinline{_______________}
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%
\q{4}{Spring 2014 Final  $|$  Q5(c)}
%%%%%%%%%%%%%%%%%%%%%

Give worst-case asymptotic $\Theta$ bounds -- you guys can write them as Big-$O$ bounds -- for the running time of the following code snippets. As a reminder, it is meaningful to write things with multiple arguments like $\Theta(a + b)$, which you can think of as ``$\Theta(N)$ where $N = a + b$."

\begin{enumerate}
\subq{1}
\begin{lstlisting}
def a(m, n):
    for i in range(m):
        for j in range(n // 100):
            print('hi')
\end{lstlisting}
~\\
\lstinline{_______________}

\subq{1}
\begin{lstlisting}
def b(m, n):
    for i in range(m // 3):
        print('hi')
    for j in range(n * 5):
        print('bye')
\end{lstlisting}
~\\
\lstinline{_______________}

\subq{1}
\begin{lstlisting}
def d(m, n):
    for i in range(m):
        j = 0
        while j < i:
            j = j + 100
\end{lstlisting}
~\\
\lstinline{_______________}

\subq{1}
\begin{lstlisting}
def f(m):
    i = 1
    while i < m:
        i = i * 2
    return i
\end{lstlisting}
~\\
\lstinline{_______________}
\end{enumerate}

\end{enumerate}
\end{document}
